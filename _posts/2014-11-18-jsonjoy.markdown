---
layout: post
title:  "JSONJoy"
date:   2014-11-18 10:00:00
author: "<a href='http://daltoniam.com'>Dalton Cherry</a>"
summary: "This week we explore how to use the JSONJoy library in Swift."
tags: apple, ios, swift, json, osx, parse, http, joy
---

I started earlier today trying to decide on what topic to write about, when I considered JSONJoy I knew it was the article to write. This topic brought up fond and joyful (sorry I had to) memories throwing back to the very first [article](/json-parsing.html). I spend a fair amount of time trying to figure out how to replicate the same dynamic parsing to no [avail](/reaction-swift-reflection.html). I then realized I was asking the wrong question, why was this functionally not provided in Swift? I decided to change my mindset and see it from a safe, static programming point of view. After this shift in thinking and several hours of programming, JSONJoy was born. 

Let's start off with a fake API server in Go.

```go
//go code here
```

If you aren't familiar with Go, no worries. This code basically returns some JSON for us to play with since most of the time our JSON comes back from an API. Let's start with the `show` route. Using [SwiftHTTP](https://github.com/daltoniam/SwiftHTTP) for the HTTP calls, we will grab our JSON from the Go API.

```swift
//Swift HTTP code and JSONJoy
```

The example above pretty much shows the basic how-to of JSONJoy. We create an object (Guitar in this case) and have it implement the `JSONJoy` protocol. The protocol requires that `init(_ decoder: JSONDecoder)` be implemented. The `JSONDecoder` object is recursive in nature, so its array and dictionary accesses both return `JSONDecoder` objects as well. `JSONDecoder` provides `String`, `Int`, `Double`, `Float`, `Bool`, `NSError`, `Array`, and `Dictionary`. Each of these return an optional. This allows picking the right type and move through nested JSON without the fear of crashing (e.g. if `name` = `decoder["someBadKey"]["nonsense"].string` it would just be set to `nil` and nothing would be wrong). One other point of interest is the `Address` object of `Guitar`. This takes advantage of the recursiveness of `JSONDecoder` to make creating other objects easy and logical as well. Let's move on to the `index` route.

```swift
//Swift HTTP code and JSONJoy
```

The `index` route returned an array of `Guitar` objects. Since we had already setup the proper parsing in `init(_ decoder: JSONDecoder)` for a single object, we simply had to iterate the array and pass the nested `JSONDecoder` objects into each new object. Now we can sell guitars with total joy (I am out of control).

JSONJoy is a simple and small library, but really encourages good MVC design. The biggest challenge for me was overcoming my hard set Objective-C ways. Swift is designed with safe and fast code in mind and while I still enjoy the Objective-C version of [JSONJoy](https://github.com/daltoniam/JSONJoy) and its unsafe and dynamic ways, I have come to accept and understand the important design choices made in Swift. I believe that in the end, it will create safer, faster, and easier to debug code. As far as programming languages go, that seems like a smart path to me. As always comments, questions, feedback, and random rants are appreciated.


[@daltoniam](https://twitter.com/daltoniam)

[JSONJoy](https://github.com/daltoniam/JSONJoy-Swift)

[SwiftHTTP](https://github.com/daltoniam/SwiftHTTP)






